**Read, Write, and Space Amplification**

LSM 트리처럼 불변 방식으로 디스크에 데이터를 저장할 때 발생하는 3가지 오버헤드 현상이 있다.

- 읽기 증폭: 데이터가 여러 파일에 흩어져 있을 경우를 고려해 어떤 키의 데이터를 읽을 때 여러 테이블에 접근함
- 쓰기 증폭: compaction 과정에서 데이터를 반복적으로 다시 쓰면서 발생.
- 공간 증폭: 동일 키에 대해서 업데이트나 삭제된 데이터도 지워지지 않고 남아있는 등 레코드가 여러 개 버전이 존재.
    
    **RUM Conjecture(추측)**
    
    스토리지 구조를 설계할 때 고려하는 읽기, 업데이트, 메모리 오버헤드 사이의 비용 관계(트레이드 오프)를 설명하는 모델
    
    위의 3가지 요소 중에서 2가지를 최적화하면 나머지 1개는 포기해야 한다
    
    - B 트리의 경우 읽기 성능을 위해 쓰기 및 공간 오버헤드 발생
    - LSM 트리의 경우 중복 레코드 저장으로 약간의 공간 오버헤드, 읽을 때 비용이 발생해도 쓰기 오버헤드가 적고 추가 공간이 필요 없다

**Implementation Details** 

LSM 트리의 구현시 공통적으로 사용되는 몇 가지 기술들이 존재함

**Sorted String Tables(SSTables)** 

LSM 트리로 디스크에 저장되는 테이블은 보통 데이터 레코드가 키 순서대로 정렬된다.

데이터가 이미 정렬되어 있기 때문에 컴팩션 발생시 인덱스 없이 데이터 파일만 순차적으로 읽은 뒤 병합

크게 2가지 부분으로 구성:

1. 데이터 파일: 키-값 쌍이 순서대로 저장된 파일
2. 인덱스 파일: 데이터 파일에 있는 특정 레코드의 오프셋 정보 저장

**Bloom Filters**

읽기 증폭 문제 해결

특정 키가 테이블에 절대 없는지 혹은 있을 수도 있는지를 매우 적은 공간만 사용해 판단하는 확률적 자료구조

→ 절대 없는 것 같은 SSTable은 참조할 필요가 없으므로 디스크 접근 횟수 감소

구조:

테이블의 모든 키를 여러 개 해시 함수에 넣어 비트 배열의 특정 위치들을 1로 설정

키를 탐색할 때 해당 키를 해시 함수에 넣어 나온 위치의 비트들이 모두 1이면 있을 가능성 있다고 판단

**Skiplist** 

LSM Tree의 인메모리(in-memory) 구성 요소인 멤테이블(memtable)을 구현할 때 사용

여러 계층의 링크드 리스트로 구성

검색 시 일부 노드를 건너뛰며 빠르게 탐색

균형 맞추기 작업 없이 확률적으로 균형을 유지해서 구현이 비교적 간단하고 동시성 제어에 유리

**Disk Access**

LSM Tree는 대부분의 테이블이 디스크에 존재하므로 디스크 접근시 페이지 캐시 사용

B Tree와는 다르게 LSM Tree의 데이터 레코드는 페이지 크기에 맞춰 정렬하지 않아도 된다

**Compression** 

공간을 절약하기 위한 압축

LSM Tree의 테이블은 불변이라 한 번에 쓰고 다시 수정하지 않기 때문에 압축이 쉽다.

압축된 데이터는 페이지 크기보다 작아지므로 압축된 페이지들의 실제 디스크 offset과 크기를 별도의 테이블에 저장

읽기가 발생하면 위치를 저장한 테이블을 참조해서 필요한 부분만 읽고 압축 해제

**Unordered LSM Storage(비정렬 로그 구조 방식)**

키 순서대로 데이터를 정렬하지 않고 입력 순서대로 저장하는 방식 → 쓰기 성능 극대화

**Bitcask**

Riak에서 사용되는 스토리지 엔진 

데이터를 정렬하지 않고 로그 파일에 순차적으로 추가

'keydir'(인메모리 해시맵)에 각 키의 최신 데이터의 로그 파일 내 위치 정보를 저장

쓰기: 파일 끝에 데이터를 추가하고 keydir만 업데이트

읽기: keydir에서 키의 위치를 바로 찾아서 한 번의 디스크 탐색으로 데이터를 읽기 가능

단점: 

모든 키를 메모리(keydir)에 올려놔야 한다

시작할 때마다 로그 파일을 읽어 keydir을 재구성해야 한다

범위 스캔(range scan)은 불가능(데이터 비정렬 상태)

**WiscKey**

Bitcask의 장점인 빠른 쓰기 속도와 정렬 스토리지의 범위 스캔을 결합

→ 키(key)와 값(value)을 분리해서 저장

- 키: 크기가 작으므로 정렬된 상태로 LSM tree에 저장
- 값: 정렬 없이 별도의 로그파일(vLog)에 순서대로 저장

LSM 트리의 키가 vLog에 있는 실제 값의 위치를 가리킴

컴팩션 부담이 적어지고 Bitcask처럼 모든 키를 메모리에 올릴 필요성 사라짐

범위 스캔 가능

다만 범위 스캔 사용시 vLog에서 값을 읽을 때 무작위 I/O이 발생
