**Chapter 7. Log-Structured Storage** 

**Log-Structured Storage**

기존의 제자리에서 수정 가능한(in-place update) 방식인 B 트리와 비교해서 설명하고 있다.

B 트리는 읽을 때 유리하지만 쓰기가 발생하면 일부 셀을 수정하기 위해 전체 페이지를 바꿔야하는 등 비용이 발생한다.

이와 다르게 immutable한 LSM 트리는 log를 기록하듯 계속 변경 사항을 데이터로 추가한다.

대신 읽을 때 여러 버전을 전부 읽어서 확인해야하는 단점이 있다.

**LSM Trees** 

쓰기 작업을 메모리에서 버퍼링한 후 디스크에 순차적으로 기록해서 쓰기 성능을 극대화한 트리 구조

- 쓰기 작업 시 작성할 위치를 찾을 필요가 없어서 쓰기 처리량이 훨씬 개선된다.
- 읽기는 디스크의 불변 파일, 쓰기는 메모리에 버퍼에서 일어나므로 락 없이 동시성 제어가 가능하다.
    
    **LSM Tree Structure**
    
    LSM-Tree는 메모리 컴포넌트와 디스크 컴포넌트로 구성된다.
    
    **Two-component LSM Tree(2-컴포넌트 LSM 트리, 딱히 한국어 번역이 없다)**
    
    - 메모리에 상주하는 트리 1개와 B-트리 형태로 디스크에 있는 큰 컴포넌트로 구성
    - 메모리에 적은 서브 트리의 일부 데이터가 디스트로 플러쉬되면 디스크의 해당 부분과 병합되어 새로운 디스크 세그먼트 형성
    - 현실에서는 쓰기 증폭이 과도한 점을 고려해 활용 사례가 적다.
    
    **Multicomponent LSM Trees(다중 컴포넌트)**
    
    - 현재 사용되는 대부분 LSM 트리의 구조
    - 디스크에 존재하는 테이블이 여러 개
    - memtable의 전체 내용이 1개의 새 디스크 데이블로 플러시
    - 디스크 내의 테이블들은 주기적으로 압축과정(compaction)으로 큰 테이블로 병합
    
    **In-memory tables(메모리 내 테이블)**
    
    1. Current Memtable
        
        현재 모든 쓰기와 읽기 요청을 처리하고 있는 테이블
        
    2. Flushing Memtable
        
        전부 차서 디스크로 기록 중인 테이블
        
        쓰기는 읽어나지 않고 읽기만 가능
        
    3. Flushed Table
        
        디스크에 기록이 완료
        
        읽기 요청 가능
        
    4. Compacting Tables / Compacted Table
        
        여러 개의 디스크 상 테이블을 병합하는 과정
        
    
    **Updates and Deletes**
    
    삭제를 직접 제거하는 것이 아니라 삭제되었다는 표시인 Tombstone(툼스톤)을 기록한다.
    
    → 툼스톤을 사용하지 않고 memtable에서 데이터만 지울 경우 나중에 오래된 디스크 테이블 상의 데이터가 읽히는 문제가 발생할 수 있다
    
    **LSM Tree Lookups(조회)**
    
    데이터를 읽으려면 Memtable, 여러 개의 디스크 테이블 모두를 확인해서 병합해야한다.
    
    **Merge-Iteration(병합 반복)**
    
    - 각 컴포넌트의 데이터는 이미 키의 순서로 정렬된 상태
    - 다중 병합 정렬 알고리즘(multiway merge-sort): 각 소스의 iterator, 우선 순위 큐를 사용
    
    **Reconciliation(조정)**
    
    - 위에서 일어나는 병합 과정에서 같은 키를 가진 데이터(최신 값, 이전 값, 툼스톤)가 여러 버전이 있을 수 있는데
      이 중에서 최종 확정값을 선택하는 과정
    - 타임스탬프가 가장 최신인 값 선택
    - 툼스톤 존재시 해당 키의 모든 데이터 무효
    
    **Maintenance in LSM Trees(유지 보수)**
    
    트리의 구조상 디스크에 파일이 계속 쌓이므로 읽기 성능 유지 및 디스크 공간을 절약하기 위해 주기적으로 압축 발생
    
    **Tombstones and Compaction**
    
    압축 과정에서 툼스톤을 바로 제거하면 압축되지 않은 더 오래된 테이블에 있는 살아있는 데이터를 막을 수 없다.
    따라서 해당 키의 모든 데이터가 전부 정리되었을 때까지 유지한다.
    
    **Leveled compaction(레벨 압축)**
    
    디스크 테이블들을 여러 개의 레벨로 나누어서 관리하는 기법
    
    - **Level 0:** Memtable에서 플러시된 테이블들, 키(key) 범위 중복 가능
    - **Level 1 이상:** 각 레벨 내 테이블들은 키 범위가 서로 겹치지 않도록 관리(읽을 때 특정 키가 있을 만한 테이블 1개만 탐색해도 된다)
    
    **Size-tiered compaction(크기 계층 압축)**
    
    테이블을 크기에 따라 분류
    
    → 테이블 고갈(table starvation) 발생 가능성:
    
    압축하려는 테이블에 툼스톤으로 삭제된 데이터가 많아서 테이블의 크기가 병합 후에 예상보다 작은 경우가 반복,
    크기가 큰 테이블이 있는 상위 계층은 압축이 거의 일어나지 않아 읽기 비용 증가
    
    → 압축 임계점을 넘지 않은 계층도 경우에 따라 강제로 압축
    
    **Time window compaction strategy(시간 창 압축)**
    
    시계열 데이터의 경우 유용
    
    쓰기 타임스탬프를 기준으로 테이블 관리
    
    유효기간(TTL)이 지난 테이블은 압축, 재작성 없이 파일 전체를 삭제
