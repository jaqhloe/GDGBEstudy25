**Concurrency in LSM Trees** 

LSM 트리의 동시성 문제: 대부분 테이블 뷰(메모리와 디스크 상의 테이블 집합)를 전환하는 과정과 로그 동기화에 관련되어있다
memtable은 일반적으로 동시에 접근이 가능하다

플러시 발생 시 동시성 규칙: 

- 새 메모리 테이블(memtable)에 쓰는 동안 플러시 중인 기존 메모리 테이블은 읽기 작업을 위해 계속 사용 가능
- 플러시 된 테이블이 디스크에 완전히 기록된 후에 기존 메모리 테이블 폐기
- 디스크 테이블의 읽기 작업은 원자적으로(atomically) 처리
- memtable과 관련된 WAL 세그먼트의 폐기와 동기화

Apache Cassandra는 memtable 플러시 전에 모든 쓰기 작업이 완료되길 기다려서 플러시 프로세스가 어떤 작업에 의존하는지 알 수 있다

**Log Stacking** 

파일 시스템 등이 여러 계층에서 로그 구조를 겹쳐서 사용하는 것

LSM 트리와 SSD는 모두 로그 구조화 저장 방식

→ 쓰기 증폭, 단편화, 성능 저하 발생 가능성 존재함

따라서 SSD의 FTL과 파일 시스템을 고려해 어플리케이션을 개발해야함

**Flash Translation Layer(FTL, 플래시 변환 계층)**

SSD는 랜덤 쓰기를 물리 페이지로 일괄 처리, program/erase 사이클 활용

쓰기 작업은 이전에 지워진 페이지에만 가능

지우기는 block 단위로만 가능

FTL은 논리적 페이지 주소를 물리적 위치에 매핑 후 페이지 상태(유호, 폐기, 빈 공간 등) 관리

빈 페이지가 부족해지면 FTL은 가비지 콜렉션으로 유효하지 않은 페이지 삭제, 

유효한 페이지는 다른 블록으로 이동

→ SSD 수명과 관련된 wear leveling(마모 평준화) 예방에도 도움

**Filesystem Logging**

파일 시스템의 쓰기 버퍼링을 위한 로깅

로그 스태킹: 상위 계층인 어플리케이션의 로그와 하ㅟㅇ 계층인 파일 시스템의 로그 중복 가능성 발생

로그 구조화 저장소가 순차 I/O에만 의존하지 않는다

데이터베이스 시스템의 쓰기 스트림이 교차되면 단편화가 발생할 수있다

**LLAMA and Mindful Stacking(신중한 스태킹)**

Bw-Tree는 LLAMA라는 래치 없는 로그 구조화 저장소 위에 구축

LLAMA는 여러 delta node를 하나의 물리적 위치로 통합하는 가비지 컬렉션 수행

→ 델타 노드가 적용된 새로운 베이스 노드를 생성함으로써 스토리지 공간 절약, 읽기 지연 줄임

→ 스택형 구조는 API를 통해 적절한 정보를 노출함으로써 통합 효율성 개선 가능하다

**Open-Channel SSDs**

파일 시스템이나 FTL을 우회해 SSD hardware에 직접 접근하는 방식

(LOCS나 LightNVM 등)

**Part 1을 마치며**

**1. 데이터베이스 시스템의 구성 및 분류**

- DBMS: 운송 계층, 쿼리 프로세서, 실행 엔진, 스토리지 엔진으로 구성
- 스토리지 엔진: 데이터를 메모리와 디스크에 저장, 검색, 관리하는 소프트웨어 컴포넌트
- 데이터베이스는 저장 매체에 따라 인메모리(in-memory) 또는 디스크 기반(disk-based)
- 데이터 저장 방식에 따라 행 지향(row-oriented)과 열 지향(column-oriented)으로도 분류됨

**2. B-Tree 기본 원리 및 구현**

- B-Tree는 디스크 기반 인덱스 구조로, 높은 팬아웃과 낮은 높이를 통해 디스크 I/O를 최소화
- 삽입 시 노드가 가득 차면 노드 분할(split)이, 삭제 시 노드가 비면 노드 병합(merge)이 발생
- 디스크 구현 시 페이지 헤더, 마법 숫자(magic numbers), 형제 링크(sibling links), 오버플로 페이지(overflow pages) 같은 기법을 사용

**3. 트랜잭션 처리 및 복구**

- 트랜잭션은 ACID(원자성, 일관성, 고립성, 내구성) 속성을 보장해야 함
- 페이지 캐시는 디스크 I/O를 줄이고, WAL(쓰기 전 로그)은 데이터 내구성을 보장함
- 동시성 제어: 여러 트랜잭션이 충돌 없이 실행되게 하는 기법,
  비관적(pessimistic), 낙관적(optimistic), MVCC(multiversion concurrency control) 등

**4. B-Tree 변형 및 로그 구조화 저장소**

- Copy-on-write B-Trees: 페이지를 불변(immutable)하게 만들어 동시성 제어를 단순화
- Lazy B-Trees: 업데이트를 버퍼링해 I/O 요청 횟수를 줄인다
- Bw-Tree: 델타 노드와 베이스 노드로 구성된 논리적 노드를 쓰며, 래치(latch) 없이 compare-and-swap으로 동시성을 제어
- LSM-Tree: 불변 파일을 사용, 쓰기를 메모리에 버퍼링한 뒤 디스크에 순차적으로 기록
    → 컴팩션(compaction)으로 불변 테이블을 병합해 공간을 확보하고 읽기 성능을 개선
- Bitcask, WiscKey: 데이터를 정렬 없이 저장해 쓰기 성능 개선

**5. 스토리지 엔진의 트레이드오프**

- 모든 스토리지 엔진은 버퍼링, 불변성, 정렬 속성을 조합해서 특정 목적에 맞춰 설계
- RUM(Read, Update, Memory) 가설에 따라, 읽기, 쓰기, 메모리 오버헤드 중 두 개를 줄이면 나머지 하나가 증가하는 트레이드오프가 존재
- B-Tree는 읽기 최적화, LSM-Tree는 쓰기 최적화 구조
