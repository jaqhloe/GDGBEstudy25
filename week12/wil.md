**Bw-Trees(Buzzword-Trees)** 

→ write amplification 해결, nonblocking access, cache friendliness

트리의 구현이 제자리 쓰기를 할 때 쓰기 증폭은 필연적으로 발생한다.

- 페이지를 업데이트할 때 디스크 페이지의 복사본 필요
- 공간이 추가로 필요함
- 동시성 제어 문제가 발생하고 래치도 구현해야 함

위의 3가지 문제를 모두 해결하기 위해 Buzzword-Tree가 등장

- append-only storage
- 노드를 링크로 연결해 체인 형성
- 메모리 상 존재
- 1번의 compare and swap 연산으로 노드 간 포인터 설정 가능
- 락 없이 작동
    
    **Update Chains**
    
    base node에 변경 사항을 추가하는 delta nodes를 체인처럼 붙여서 사용함
    
    insert, update, delete 모두 delta node
    
    모든 변경 사항이 이 체인의 앞쪽에 붙기 때문에 추가로 공간을 준비할 필요가 없다
    
    논리적 노드이기 때문에 읽기를 수행하는 동안 체인을 전부 가로질러야하는 단점
    
    **Taming Concurrency with Compare-and-Swap**
    
    디스크가 아닌 메모리 상에 논리적 식별자와 매핑 테이블을 둬서 래치를 사용하지 않는다
    
    버즈 워드 트리를 업데이트 하기 위해서 3단계를 거친다
    
    - 수정하려는 논리적 잎 노드를 매핑 테이블에서 virtual link로 base node를 찾거나 최신 delta node로 찾는다
    - 위의 과정을 진행하는 중에 새로운 delta node가 생성되어 체인에 붙는다
    - 매핑 테이블도 상황을 반영해서 업데이트한다.
        
        이 과정은 더 이상 분리될 수 없는 연산인 compare-and-swap을 이용해서 발생한다. 
        
        따라서 모든 읽기는 포인터 업데이트와 함께 발생하는데, 쓰기의 전이나 후 둘 중에 하나로 분류된다. 
        
        쓰기의 전으로 분류된 읽기는 새로 만들어진 델타 노드의 존재를 모르고
        
        쓰기의 이후로 분류된 읽기는 업데이트를 읽을 수 있다
        
        2개의 쓰레드가 동시에 새로운 델타노드를 같은 논리적 노드에 붙이려고 하면 한 개만 성공하고 
        
        붙이려는 노드와 다른 포인터 값을 예상한 연산은 실패해 다시 시도한다.
        
    
    **Structural Modification Operations**
    
    B-tree와 여전히 논리적으로 동일한 형태이기 때문에 오버플로와 언더플로가 발생할 수 있고,
    분할과 병합 같은 structural modification operation(SMO)가 필요하다.
    
    - 분할 과정은 먼저 분할하려는 노드의 논리적 델타 노드를 전부 합치고 분할 지점의 오른쪽에 새로운 페이지를 생성하는 것으로 시작한다.
        
        그 다음 분할을 위한 델타 노드를 추가해서 다른 읽기 작업에도 상황을 알린다.
        
        분할 델타 노드는 중간 분할자(midpoint seperator key)를 가지고 있어서 분할되고 있는 노드의 기록들에 접근하지 않게 막는다.
        
        또한 새로운 논리적 형제 노드와 연결되는 링크도 가지고 있다.
        
        B link tree의 절반 분할과 유사하게 split delta node pointer로 해당 노드를 접근할 수는 있으나
        
        아직 부모 노드로부터는 참조가 불가능한 상황이다. 
        
        새로운 노드를 읽기 위해서는 형제 노드의 포인터를 통해서 접근해야 한다.
        
        이후 부모 노드와 연결된다. 
        
    - 병합 과정도 분할 과정과 비슷하게 일어난다.
        
        remove delta node가 오른쪽 자녀에 붙어서 해당 오른쪽 자녀가 병합될 것임을 표시한다.
        
        왼쪽 자녀에 merge delta node가 붙어서 오른쪽 자녀의 내용을 가르키게 하고
        
        오른쪽 자녀의 내용이 논리적으로 왼쪽의 것이 되게 한다.
        
        부모 노드에서 오른쪽 자녀의 내용을 접근할 수 없는 것으로 설정한다.
        
    - Concurrent SMO는 abort delta node라는 추가적인 장치로 동시에 분할과 병합이 일어나지 않게 막는다.(쓰기 잠금과 유사)
    
    **Consolidation and Garbage Collection**
    
    - Consolidation
        
        델타 체인이 임계점 이상으로 너무 길어지면 읽기를 수행하기 힘들어지므로 전부 베이스 노드에 합친다.
        이 과정에서 새로 만들어진 노드는 디스크의 새로운 위치에 기록된다.
        
    - Garbage collection
        
        하지만 위의 과정을 실행했을 때 진행중인 읽기 작업이 있을 수 있고
        
        live page를 관리하는 방법이 필요하므로 epoch-based reclamation이 등장한다.
        
        따라서 해당 epoch 이전에 시작된 읽기 작업은 기존의 내용을 접근할 수 있고
        
        이 작업이 끝나야 가비지 콜렉팅이 된다.
        

**Cache-Oblivious B-Trees**

트리의 성능에 영향을 줄 수 있는 요인들(블록 크기, 노드 크기, cache line alignments, 
configurable parameters) 등과 상관 없이 항상 비슷한 성능을 내도록 설계된 트리이다.

기존의 경우 page cache와 디스크의 이중 계층 구조로 이루어져 있었으나

이 트리는 2가지의 변수만 사용한다. 따라서 고려할 사항이 적다.

**van Emde Boas Layout**

위에서 소개한 캐시 무관 b tree는 정적인 비 트리와 데이터를 조밀하게 저장하는 배열(packed array structure)로 이루어져 있다. 

각 서브트리는 재귀적으로 분할해서 메모리의 연속적인 공간에 저장된다.

다만 동적인 구조를 유지하기 위해 배열의 중간중간에 빈 공간(gap)을 마련해둔다.

검색할 때는 정적인 트리에서 검색해서 내용을 찾는다.

하지만 장점에도 불구하고 페이징과 페이지 쫓아내기 시 성능 저하와 

블록 전송시 기존 방법과 큰 차이가 없다는 점에서 아직 활용 사례가 적다.

비휘발성 바이트 주소 지정 가능 저장 장치가 더 흔해지면 이 방법을 사용하는 경우를 찾기 쉬워질 것이다.
